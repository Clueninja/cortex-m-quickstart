var N = null;var searchIndex = {};
searchIndex["aligned"]={"doc":"Statically allocated arrays with guaranteed memory alignments","items":[[3,"Aligned","aligned","An `ARRAY` aligned to `mem::align_of::<ALIGNMENT>()` bytes",N,N],[12,"array","","The array",0,N],[5,"Aligned","","`Aligned` constructor",N,[[["array"]],["aligned"]]],[8,"Alignment","","IMPLEMENTATION DETAIL",N,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"deref","","",0,N],[11,"deref_mut","","",0,N],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]]],"paths":[[3,"Aligned"]]};
searchIndex["bare_metal"]={"doc":"Abstractions common to bare metal systems","items":[[3,"Peripheral","bare_metal","A peripheral",N,N],[3,"CriticalSection","","Critical section token",N,N],[3,"Mutex","","A \"mutex\" based on critical sections",N,N],[8,"Nr","","Interrupt number",N,N],[10,"nr","","Returns the number associated with an interrupt",0,[[["self"]],["u8"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new peripheral",1,[[["usize"]],["self"]]],[11,"borrow","","Borrows the peripheral for the duration of a critical section",1,[[["self"],["criticalsection"]],["t"]]],[11,"get","","Returns a pointer to the register block",1,N],[11,"new","","Creates a critical section token",2,[[],["self"]]],[11,"new","","Creates a new mutex",3,[[["t"]],["self"]]],[11,"borrow","","Borrows the data for the duration of the critical section",3,[[["self"],["criticalsection"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]]],"paths":[[8,"Nr"],[3,"Peripheral"],[3,"CriticalSection"],[3,"Mutex"]]};
searchIndex["cortex_m"]={"doc":"Low level access to Cortex-M processors","items":[[0,"asm","cortex_m","Miscellaneous assembly instructions",N,N],[5,"bkpt","cortex_m::asm","Puts the processor in Debug state. Debuggers can pick this up as a \"breakpoint\".",N,[[]]],[5,"delay","","Blocks the program for at least `n` instruction cycles",N,[[["u32"]]]],[5,"nop","","A no-operation. Useful to prevent delay loops from being optimized away.",N,[[]]],[5,"wfe","","Wait For Event",N,[[]]],[5,"wfi","","Wait For Interrupt",N,[[]]],[5,"sev","","Send Event",N,[[]]],[5,"isb","","Instruction Synchronization Barrier",N,[[]]],[5,"dsb","","Data Synchronization Barrier",N,[[]]],[5,"dmb","","Data Memory Barrier",N,[[]]],[0,"interrupt","cortex_m","Interrupts",N,N],[3,"CriticalSection","cortex_m::interrupt","Critical section token",N,N],[3,"Mutex","","A \"mutex\" based on critical sections",N,N],[8,"Nr","","Interrupt number",N,N],[10,"nr","","Returns the number associated with an interrupt",0,[[["self"]],["u8"]]],[5,"disable","","Disables all interrupts",N,[[]]],[5,"enable","","Enables all the interrupts",N,[[]]],[5,"free","","Execute closure `f` in an interrupt-free context.",N,[[["f"]],["r"]]],[0,"itm","cortex_m","Instrumentation Trace Macrocell",N,N],[5,"write_all","cortex_m::itm","Writes a `buffer` to the ITM `port`",N,N],[5,"write_aligned","","Writes a 4-byte aligned `buffer` to the ITM `port`",N,[[["stim"],["aligned"]]]],[5,"write_fmt","","Writes `fmt::Arguments` to the ITM `port`",N,[[["stim"],["arguments"]]]],[5,"write_str","","Writes a string to the ITM `port`",N,[[["stim"],["str"]]]],[0,"peripheral","cortex_m","Core peripherals",N,N],[3,"Peripherals","cortex_m::peripheral","Core peripherals",N,N],[12,"CBP","","Cache and branch predictor maintenance operations (not present on Cortex-M0 variants)",1,N],[12,"CPUID","","CPUID",1,N],[12,"DCB","","Debug Control Block",1,N],[12,"DWT","","Data Watchpoint and Trace unit",1,N],[12,"FPB","","Flash Patch and Breakpoint unit (not present on Cortex-M0 variants)",1,N],[12,"FPU","","Floating Point Unit (only present on `thumbv7em-none-eabihf`)",1,N],[12,"ITM","","Instrumentation Trace Macrocell (not present on Cortex-M0 variants)",1,N],[12,"MPU","","Memory Protection Unit",1,N],[12,"NVIC","","Nested Vector Interrupt Controller",1,N],[12,"SCB","","System Control Block",1,N],[12,"SYST","","SysTick: System Timer",1,N],[12,"TPIU","","Trace Port Interface Unit (not present on Cortex-M0 variants)",1,N],[3,"CBP","","Cache and branch predictor maintenance operations",N,N],[3,"CPUID","","CPUID",N,N],[3,"DCB","","Debug Control Block",N,N],[3,"DWT","","Data Watchpoint and Trace unit",N,N],[3,"FPB","","Flash Patch and Breakpoint unit",N,N],[3,"FPU","","Floating Point Unit",N,N],[3,"ITM","","Instrumentation Trace Macrocell",N,N],[3,"MPU","","Memory Protection Unit",N,N],[3,"NVIC","","Nested Vector Interrupt Controller",N,N],[3,"SCB","","System Control Block",N,N],[3,"SYST","","SysTick: System Timer",N,N],[3,"TPIU","","Trace Port Interface Unit",N,N],[0,"cbp","","Cache and branch predictor maintenance operations",N,N],[3,"RegisterBlock","cortex_m::peripheral::cbp","Register block",N,N],[12,"iciallu","","I-cache invalidate all to PoU",2,N],[12,"icimvau","","I-cache invalidate by MVA to PoU",2,N],[12,"dcimvac","","D-cache invalidate by MVA to PoC",2,N],[12,"dcisw","","D-cache invalidate by set-way",2,N],[12,"dccmvau","","D-cache clean by MVA to PoU",2,N],[12,"dccmvac","","D-cache clean by MVA to PoC",2,N],[12,"dccsw","","D-cache clean by set-way",2,N],[12,"dccimvac","","D-cache clean and invalidate by MVA to PoC",2,N],[12,"dccisw","","D-cache clean and invalidate by set-way",2,N],[12,"bpiall","","Branch predictor invalidate all",2,N],[11,"iciallu","cortex_m::peripheral","I-cache invalidate all to PoU",3,[[["self"]]]],[11,"icimvau","","I-cache invalidate by MVA to PoU",3,[[["self"],["u32"]]]],[11,"dcimvac","","D-cache invalidate by MVA to PoC",3,[[["self"],["u32"]]]],[11,"dcisw","","D-cache invalidate by set-way",3,[[["self"],["u16"],["u16"]]]],[11,"dccmvau","","D-cache clean by MVA to PoU",3,[[["self"],["u32"]]]],[11,"dccmvac","","D-cache clean by MVA to PoC",3,[[["self"],["u32"]]]],[11,"dccsw","","D-cache clean by set-way",3,[[["self"],["u16"],["u16"]]]],[11,"dccimvac","","D-cache clean and invalidate by MVA to PoC",3,[[["self"],["u32"]]]],[11,"dccisw","","D-cache clean and invalidate by set-way",3,[[["self"],["u16"],["u16"]]]],[11,"bpiall","","Branch predictor invalidate all",3,[[["self"]]]],[0,"cpuid","","CPUID",N,N],[3,"RegisterBlock","cortex_m::peripheral::cpuid","Register block",N,N],[12,"base","","CPUID base",4,N],[12,"pfr","","Processor Feature (not present on Cortex-M0 variants)",4,N],[12,"dfr","","Debug Feature (not present on Cortex-M0 variants)",4,N],[12,"afr","","Auxiliary Feature (not present on Cortex-M0 variants)",4,N],[12,"mmfr","","Memory Model Feature (not present on Cortex-M0 variants)",4,N],[12,"isar","","Instruction Set Attribute (not present on Cortex-M0 variants)",4,N],[12,"clidr","","Cache Level ID (only present on Cortex-M7)",4,N],[12,"ctr","","Cache Type (only present on Cortex-M7)",4,N],[12,"ccsidr","","Cache Size ID (only present on Cortex-M7)",4,N],[12,"csselr","","Cache Size Selection (only present on Cortex-M7)",4,N],[4,"CsselrCacheType","","Type of cache to select on CSSELR writes.",N,N],[13,"DataOrUnified","","Select DCache or unified cache",5,N],[13,"Instruction","","Select ICache",5,N],[11,"select_cache","cortex_m::peripheral","Selects the current CCSIDR",6,[[["self"],["u8"],["csselrcachetype"]]]],[11,"cache_num_sets_ways","","Returns the number of sets and ways in the selected cache",6,N],[0,"dcb","","Debug Control Block",N,N],[3,"RegisterBlock","cortex_m::peripheral::dcb","Register block",N,N],[12,"dhcsr","","Debug Halting Control and Status",7,N],[12,"dcrsr","","Debug Core Register Selector",7,N],[12,"dcrdr","","Debug Core Register Data",7,N],[12,"demcr","","Debug Exception and Monitor Control",7,N],[0,"dwt","cortex_m::peripheral","Data Watchpoint and Trace unit",N,N],[3,"RegisterBlock","cortex_m::peripheral::dwt","Register block",N,N],[12,"ctrl","","Control",8,N],[12,"cyccnt","","Cycle Count",8,N],[12,"cpicnt","","CPI Count",8,N],[12,"exccnt","","Exception Overhead Count",8,N],[12,"sleepcnt","","Sleep Count",8,N],[12,"lsucnt","","LSU Count",8,N],[12,"foldcnt","","Folded-instruction Count",8,N],[12,"pcsr","","Program Counter Sample",8,N],[12,"c","","Comparators",8,N],[12,"lar","","Lock Access",8,N],[12,"lsr","","Lock Status",8,N],[3,"Comparator","","Comparator",N,N],[12,"comp","","Comparator",9,N],[12,"mask","","Comparator Mask",9,N],[12,"function","","Comparator Function",9,N],[11,"enable_cycle_counter","cortex_m::peripheral","Enables the cycle counter",10,[[["self"]]]],[11,"get_cycle_count","","Returns the current clock cycle count",10,[[],["u32"]]],[0,"fpb","","Flash Patch and Breakpoint unit",N,N],[3,"RegisterBlock","cortex_m::peripheral::fpb","Register block",N,N],[12,"ctrl","","Control",11,N],[12,"remap","","Remap",11,N],[12,"comp","","Comparator",11,N],[12,"lar","","Lock Access",11,N],[12,"lsr","","Lock Status",11,N],[0,"fpu","cortex_m::peripheral","Floating Point Unit",N,N],[3,"RegisterBlock","cortex_m::peripheral::fpu","Register block",N,N],[12,"fpccr","","Floating Point Context Control",12,N],[12,"fpcar","","Floating Point Context Address",12,N],[12,"fpdscr","","Floating Point Default Status Control",12,N],[12,"mvfr","","Media and FP Feature",12,N],[0,"itm","cortex_m::peripheral","Instrumentation Trace Macrocell",N,N],[3,"RegisterBlock","cortex_m::peripheral::itm","Register block",N,N],[12,"stim","","Stimulus Port",13,N],[12,"ter","","Trace Enable",13,N],[12,"tpr","","Trace Privilege",13,N],[12,"tcr","","Trace Control",13,N],[12,"lar","","Lock Access",13,N],[12,"lsr","","Lock Status",13,N],[3,"Stim","","Stimulus Port",N,N],[11,"write_u8","","Writes an `u8` payload into the stimulus port",14,[[["self"],["u8"]]]],[11,"write_u16","","Writes an `u16` payload into the stimulus port",14,[[["self"],["u16"]]]],[11,"write_u32","","Writes an `u32` payload into the stimulus port",14,[[["self"],["u32"]]]],[11,"is_fifo_ready","","Returns `true` if the stimulus port is ready to accept more data",14,[[["self"]],["bool"]]],[0,"mpu","cortex_m::peripheral","Memory Protection Unit",N,N],[3,"RegisterBlock","cortex_m::peripheral::mpu","Register block",N,N],[12,"_type","","Type",15,N],[12,"ctrl","","Control",15,N],[12,"rnr","","Region Number",15,N],[12,"rbar","","Region Base Address",15,N],[12,"rasr","","Region Attribute and Size",15,N],[12,"rbar_a1","","Alias 1 of RBAR",15,N],[12,"rsar_a1","","Alias 1 of RSAR",15,N],[12,"rbar_a2","","Alias 2 of RBAR",15,N],[12,"rsar_a2","","Alias 2 of RSAR",15,N],[12,"rbar_a3","","Alias 3 of RBAR",15,N],[12,"rsar_a3","","Alias 3 of RSAR",15,N],[0,"nvic","cortex_m::peripheral","Nested Vector Interrupt Controller",N,N],[3,"RegisterBlock","cortex_m::peripheral::nvic","Register block",N,N],[12,"iser","","Interrupt Set-Enable",16,N],[12,"icer","","Interrupt Clear-Enable",16,N],[12,"ispr","","Interrupt Set-Pending",16,N],[12,"icpr","","Interrupt Clear-Pending",16,N],[12,"iabr","","Interrupt Active Bit (not present on Cortex-M0 variants)",16,N],[12,"ipr","","Interrupt Priority",16,N],[11,"clear_pending","cortex_m::peripheral","Clears `interrupt`'s pending state",17,[[["self"],["i"]]]],[11,"disable","","Disables `interrupt`",17,[[["self"],["i"]]]],[11,"enable","","Enables `interrupt`",17,[[["self"],["i"]]]],[11,"get_priority","","Returns the NVIC priority of `interrupt`",17,[[["i"]],["u8"]]],[11,"is_active","","Is `interrupt` active or pre-empted and stacked",17,[[["i"]],["bool"]]],[11,"is_enabled","","Checks if `interrupt` is enabled",17,[[["i"]],["bool"]]],[11,"is_pending","","Checks if `interrupt` is pending",17,[[["i"]],["bool"]]],[11,"set_pending","","Forces `interrupt` into pending state",17,[[["self"],["i"]]]],[11,"set_priority","","Sets the \"priority\" of `interrupt` to `prio`",17,[[["self"],["i"],["u8"]]]],[0,"scb","","System Control Block",N,N],[3,"RegisterBlock","cortex_m::peripheral::scb","Register block",N,N],[12,"icsr","","Interrupt Control and State",18,N],[12,"vtor","","Vector Table Offset (not present on Cortex-M0 variants)",18,N],[12,"aircr","","Application Interrupt and Reset Control",18,N],[12,"scr","","System Control",18,N],[12,"ccr","","Configuration and Control",18,N],[12,"shpr","","System Handler Priority (word accessible only on Cortex-M0 variants)",18,N],[12,"shcrs","","System Handler Control and State",18,N],[12,"cfsr","","Configurable Fault Status (not present on Cortex-M0 variants)",18,N],[12,"hfsr","","HardFault Status (not present on Cortex-M0 variants)",18,N],[12,"dfsr","","Debug Fault Status (not present on Cortex-M0 variants)",18,N],[12,"mmfar","","MemManage Fault Address (not present on Cortex-M0 variants)",18,N],[12,"bfar","","BusFault Address (not present on Cortex-M0 variants)",18,N],[12,"afsr","","Auxiliary Fault Status (not present on Cortex-M0 variants)",18,N],[12,"cpacr","","Coprocessor Access Control (not present on Cortex-M0 variants)",18,N],[4,"Exception","","Processor core exceptions (internal interrupts)",N,N],[13,"NonMaskableInt","","Non maskable interrupt",19,N],[13,"HardFault","","Hard fault interrupt",19,N],[13,"MemoryManagement","","Memory management interrupt (not present on Cortex-M0 variants)",19,N],[13,"BusFault","","Bus fault interrupt (not present on Cortex-M0 variants)",19,N],[13,"UsageFault","","Usage fault interrupt (not present on Cortex-M0 variants)",19,N],[13,"SecureFault","","Secure fault interrupt (only on ARMv8-M)",19,N],[13,"SVCall","","SV call interrupt",19,N],[13,"DebugMonitor","","Debug monitor interrupt (not present on Cortex-M0 variants)",19,N],[13,"PendSV","","Pend SV interrupt",19,N],[13,"SysTick","","System Tick interrupt",19,N],[4,"VectActive","","Active exception number",N,N],[13,"ThreadMode","","Thread mode",20,N],[13,"Exception","","Processor core exception (internal interrupts)",20,N],[13,"Interrupt","","Device specific exception (external interrupts)",20,N],[12,"irqn","cortex_m::peripheral::scb::VectActive","Interrupt number. This number is always within half open range `[0, 240)`",20,N],[11,"vect_active","cortex_m::peripheral","Returns the active exception number",21,[[],["vectactive"]]],[11,"clone","cortex_m::peripheral::scb","",19,[[["self"]],["exception"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"eq","","",19,[[["self"],["exception"]],["bool"]]],[11,"irqn","","Returns the IRQ number of this `Exception`",19,[[["self"]],["i8"]]],[11,"clone","","",20,[[["self"]],["vectactive"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"eq","","",20,[[["self"],["vectactive"]],["bool"]]],[11,"ne","","",20,[[["self"],["vectactive"]],["bool"]]],[11,"from","","Converts a `byte` into `VectActive`",20,[[["u8"]],["option"]]],[11,"enable_icache","cortex_m::peripheral","Enables I-Cache if currently disabled",21,[[["self"]]]],[11,"disable_icache","","Disables I-Cache if currently enabled",21,[[["self"]]]],[11,"icache_enabled","","Returns whether the I-Cache is currently enabled",21,[[],["bool"]]],[11,"invalidate_icache","","Invalidates I-Cache",21,[[["self"]]]],[11,"enable_dcache","","Enables D-cache if currently disabled",21,[[["self"],["cpuid"]]]],[11,"disable_dcache","","Disables D-cache if currently enabled",21,[[["self"],["cpuid"]]]],[11,"dcache_enabled","","Returns whether the D-Cache is currently enabled",21,[[],["bool"]]],[11,"clean_dcache","","Cleans D-cache",21,[[["self"],["cpuid"]]]],[11,"clean_invalidate_dcache","","Cleans and invalidates D-cache",21,[[["self"],["cpuid"]]]],[11,"invalidate_dcache_by_address","","Invalidates D-cache by address",21,[[["self"],["usize"],["usize"]]]],[11,"clean_dcache_by_address","","Cleans D-cache by address",21,[[["self"],["usize"],["usize"]]]],[11,"clean_invalidate_dcache_by_address","","Cleans and invalidates D-cache by address",21,[[["self"],["usize"],["usize"]]]],[11,"set_sleepdeep","","Set the SLEEPDEEP bit in the SCR register",21,[[["self"]]]],[11,"clear_sleepdeep","","Clear the SLEEPDEEP bit in the SCR register",21,[[["self"]]]],[11,"system_reset","","Initiate a system reset request to reset the MCU",21,N],[0,"syst","","SysTick: System Timer",N,N],[3,"RegisterBlock","cortex_m::peripheral::syst","Register block",N,N],[12,"csr","","Control and Status",22,N],[12,"rvr","","Reload Value",22,N],[12,"cvr","","Current Value",22,N],[12,"calib","","Calibration Value",22,N],[4,"SystClkSource","","SysTick clock source",N,N],[13,"Core","","Core-provided clock",23,N],[13,"External","","External reference clock",23,N],[11,"clone","","",23,[[["self"]],["systclksource"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"clear_current","cortex_m::peripheral","Clears current value to 0",24,[[["self"]]]],[11,"disable_counter","","Disables counter",24,[[["self"]]]],[11,"disable_interrupt","","Disables SysTick interrupt",24,[[["self"]]]],[11,"enable_counter","","Enables counter",24,[[["self"]]]],[11,"enable_interrupt","","Enables SysTick interrupt",24,[[["self"]]]],[11,"get_clock_source","","Gets clock source",24,[[["self"]],["systclksource"]]],[11,"get_current","","Gets current value",24,[[],["u32"]]],[11,"get_reload","","Gets reload value",24,[[],["u32"]]],[11,"get_ticks_per_10ms","","Returns the reload value with which the counter would wrap once per 10 ms",24,[[],["u32"]]],[11,"has_reference_clock","","Checks if an external reference clock is available",24,[[],["bool"]]],[11,"has_wrapped","","Checks if the counter wrapped (underflowed) since the last check",24,[[["self"]],["bool"]]],[11,"is_counter_enabled","","Checks if counter is enabled",24,[[["self"]],["bool"]]],[11,"is_interrupt_enabled","","Checks if SysTick interrupt is enabled",24,[[["self"]],["bool"]]],[11,"is_precise","","Checks if the calibration value is precise",24,[[],["bool"]]],[11,"set_clock_source","","Sets clock source",24,[[["self"],["systclksource"]]]],[11,"set_reload","","Sets reload value",24,[[["self"],["u32"]]]],[0,"tpiu","","Trace Port Interface Unit;",N,N],[3,"RegisterBlock","cortex_m::peripheral::tpiu","Register block",N,N],[12,"sspsr","","Supported Parallel Port Sizes",25,N],[12,"cspsr","","Current Parallel Port Size",25,N],[12,"acpr","","Asynchronous Clock Prescaler",25,N],[12,"sppr","","Selected Pin Control",25,N],[12,"ffcr","","Formatter and Flush Control",25,N],[12,"lar","","Lock Access",25,N],[12,"lsr","","Lock Status",25,N],[12,"_type","","TPIU Type",25,N],[11,"take","cortex_m::peripheral","Returns all the core peripherals once",1,[[],["option"]]],[11,"steal","","Unchecked version of `Peripherals::take`",1,[[],["self"]]],[11,"ptr","","Returns a pointer to the register block",3,N],[11,"deref","","",3,N],[11,"ptr","","Returns a pointer to the register block",6,N],[11,"deref","","",6,N],[11,"ptr","","Returns a pointer to the register block",26,N],[11,"deref","","",26,N],[11,"ptr","","Returns a pointer to the register block",10,N],[11,"deref","","",10,N],[11,"ptr","","Returns a pointer to the register block",27,N],[11,"deref","","",27,N],[11,"ptr","","Returns a pointer to the register block",28,N],[11,"deref","","",28,N],[11,"ptr","","Returns a pointer to the register block",29,N],[11,"deref","","",29,N],[11,"deref_mut","","",29,N],[11,"ptr","","Returns a pointer to the register block",30,N],[11,"deref","","",30,N],[11,"ptr","","Returns a pointer to the register block",17,N],[11,"deref","","",17,N],[11,"ptr","","Returns a pointer to the register block",21,N],[11,"deref","","",21,N],[11,"ptr","","Returns a pointer to the register block",24,N],[11,"deref","","",24,N],[11,"ptr","","Returns a pointer to the register block",31,N],[11,"deref","","",31,N],[0,"register","cortex_m","Processor core registers",N,N],[0,"basepri","cortex_m::register","Base Priority Mask Register",N,N],[5,"read","cortex_m::register::basepri","Reads the CPU register",N,[[],["u8"]]],[5,"write","","Writes to the CPU register",N,[[["u8"]]]],[0,"basepri_max","cortex_m::register","Base Priority Mask Register (conditional write)",N,N],[5,"write","cortex_m::register::basepri_max","Writes to BASEPRI if",N,[[["u8"]]]],[0,"control","cortex_m::register","Control register",N,N],[3,"Control","cortex_m::register::control","Control register",N,N],[4,"Npriv","","Thread mode privilege level",N,N],[13,"Privileged","","Privileged",32,N],[13,"Unprivileged","","Unprivileged",32,N],[4,"Spsel","","Currently active stack pointer",N,N],[13,"Msp","","MSP is the current stack pointer",33,N],[13,"Psp","","PSP is the current stack pointer",33,N],[4,"Fpca","","Whether context floating-point is currently active",N,N],[13,"Active","","Floating-point context active.",34,N],[13,"NotActive","","No floating-point context active",34,N],[5,"read","","Reads the CPU register",N,[[],["control"]]],[11,"clone","","",35,[[["self"]],["control"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"bits","","Returns the contents of the register as raw bits",35,[[["self"]],["u32"]]],[11,"npriv","","Thread mode privilege level",35,[[["self"]],["npriv"]]],[11,"spsel","","Currently active stack pointer",35,[[["self"]],["spsel"]]],[11,"fpca","","Whether context floating-point is currently active",35,[[["self"]],["fpca"]]],[11,"clone","","",32,[[["self"]],["npriv"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"eq","","",32,[[["self"],["npriv"]],["bool"]]],[11,"is_privileged","","Is in privileged thread mode?",32,[[["self"]],["bool"]]],[11,"is_unprivileged","","Is in unprivileged thread mode?",32,[[["self"]],["bool"]]],[11,"clone","","",33,[[["self"]],["spsel"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"eq","","",33,[[["self"],["spsel"]],["bool"]]],[11,"is_msp","","Is MSP the current stack pointer?",33,[[["self"]],["bool"]]],[11,"is_psp","","Is PSP the current stack pointer?",33,[[["self"]],["bool"]]],[11,"clone","","",34,[[["self"]],["fpca"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"eq","","",34,[[["self"],["fpca"]],["bool"]]],[11,"is_active","","Is a floating-point context active?",34,[[["self"]],["bool"]]],[11,"is_not_active","","Is a floating-point context not active?",34,[[["self"]],["bool"]]],[0,"faultmask","cortex_m::register","Fault Mask Register",N,N],[4,"Faultmask","cortex_m::register::faultmask","All exceptions are ...",N,N],[13,"Active","","Active",36,N],[13,"Inactive","","Inactive, expect for NMI",36,N],[5,"read","","Reads the CPU register",N,[[],["faultmask"]]],[11,"clone","","",36,[[["self"]],["faultmask"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"eq","","",36,[[["self"],["faultmask"]],["bool"]]],[11,"is_active","","All exceptions are active",36,[[["self"]],["bool"]]],[11,"is_inactive","","All exceptions, except for NMI, are inactive",36,[[["self"]],["bool"]]],[0,"msp","cortex_m::register","Main Stack Pointer",N,N],[5,"read","cortex_m::register::msp","Reads the CPU register",N,[[],["u32"]]],[5,"write","","Writes `bits` to the CPU register",N,[[["u32"]]]],[0,"primask","cortex_m::register","Priority mask register",N,N],[4,"Primask","cortex_m::register::primask","All exceptions with configurable priority are ...",N,N],[13,"Active","","Active",37,N],[13,"Inactive","","Inactive",37,N],[5,"read","","Reads the CPU register",N,[[],["primask"]]],[11,"clone","","",37,[[["self"]],["primask"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"eq","","",37,[[["self"],["primask"]],["bool"]]],[11,"is_active","","All exceptions with configurable priority are active",37,[[["self"]],["bool"]]],[11,"is_inactive","","All exceptions with configurable priority are inactive",37,[[["self"]],["bool"]]],[0,"psp","cortex_m::register","Process Stack Pointer",N,N],[5,"read","cortex_m::register::psp","Reads the CPU register",N,[[],["u32"]]],[5,"write","","Writes `bits` to the CPU register",N,[[["u32"]]]],[0,"apsr","cortex_m::register","Application Program Status Register",N,N],[3,"Apsr","cortex_m::register::apsr","Application Program Status Register",N,N],[5,"read","","Reads the CPU register",N,[[],["apsr"]]],[11,"clone","","",38,[[["self"]],["apsr"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"bits","","Returns the contents of the register as raw bits",38,[[["self"]],["u32"]]],[11,"q","","DSP overflow and saturation flag",38,[[["self"]],["bool"]]],[11,"v","","Overflow flag",38,[[["self"]],["bool"]]],[11,"c","","Carry or borrow flag",38,[[["self"]],["bool"]]],[11,"z","","Zero flag",38,[[["self"]],["bool"]]],[11,"n","","Negative flag",38,[[["self"]],["bool"]]],[0,"lr","cortex_m::register","Link register",N,N],[5,"read","cortex_m::register::lr","Reads the CPU register",N,[[],["u32"]]],[5,"write","","Writes `bits` to the CPU register",N,[[["u32"]]]],[0,"pc","cortex_m::register","Program counter",N,N],[5,"read","cortex_m::register::pc","Reads the CPU register",N,[[],["u32"]]],[5,"write","","Writes `bits` to the CPU register",N,[[["u32"]]]],[14,"iprint","cortex_m","Macro for sending a formatted string through an ITM channel",N,N],[14,"iprintln","","Macro for sending a formatted string through an ITM channel, with a newline.",N,N],[14,"singleton","","Macro to create a mutable reference to a statically allocated value",N,N],[11,"new","cortex_m::interrupt","Creates a critical section token",39,[[],["criticalsection"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"from","","",39,[[["t"]],["t"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"new","","Creates a new mutex",40,[[["t"]],["mutex"]]],[11,"borrow","","Borrows the data for the duration of the critical section",40,[[["self"],["criticalsection"]],["t"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"from","","",40,[[["t"]],["t"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"from","","",29,[[["t"]],["t"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"from","","",31,[[["t"]],["t"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::cbp","",2,[[["u"]],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::cpuid","",4,[[["u"]],["result"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::dcb","",7,[[["u"]],["result"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::dwt","",8,[[["u"]],["result"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::fpb","",11,[[["u"]],["result"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::fpu","",12,[[["u"]],["result"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::itm","",13,[[["u"]],["result"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::mpu","",15,[[["u"]],["result"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::nvic","",16,[[["u"]],["result"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::scb","",18,[[["u"]],["result"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::syst","",22,[[["u"]],["result"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::peripheral::tpiu","",25,[[["u"]],["result"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::register::control","",35,[[["u"]],["result"]]],[11,"from","","",35,[[["t"]],["t"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"from","","",32,[[["t"]],["t"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::register::faultmask","",36,[[["u"]],["result"]]],[11,"from","","",36,[[["t"]],["t"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::register::primask","",37,[[["u"]],["result"]]],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_from","cortex_m::register::apsr","",38,[[["u"]],["result"]]],[11,"from","","",38,[[["t"]],["t"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]]],"paths":[[8,"Nr"],[3,"Peripherals"],[3,"RegisterBlock"],[3,"CBP"],[3,"RegisterBlock"],[4,"CsselrCacheType"],[3,"CPUID"],[3,"RegisterBlock"],[3,"RegisterBlock"],[3,"Comparator"],[3,"DWT"],[3,"RegisterBlock"],[3,"RegisterBlock"],[3,"RegisterBlock"],[3,"Stim"],[3,"RegisterBlock"],[3,"RegisterBlock"],[3,"NVIC"],[3,"RegisterBlock"],[4,"Exception"],[4,"VectActive"],[3,"SCB"],[3,"RegisterBlock"],[4,"SystClkSource"],[3,"SYST"],[3,"RegisterBlock"],[3,"DCB"],[3,"FPB"],[3,"FPU"],[3,"ITM"],[3,"MPU"],[3,"TPIU"],[4,"Npriv"],[4,"Spsel"],[4,"Fpca"],[3,"Control"],[4,"Faultmask"],[4,"Primask"],[3,"Apsr"],[3,"CriticalSection"],[3,"Mutex"]]};
searchIndex["cortex_m_quickstart"]={"doc":"A template for building applications for ARM Cortex-M microcontrollers","items":[[0,"examples","cortex_m_quickstart","Examples sorted in increasing degree of complexity",N,N],[0,"_0_minimal","cortex_m_quickstart::examples","Minimal Cortex-M program",N,N],[0,"_1_hello","","Prints \"Hello, world!\" on the OpenOCD console using semihosting",N,N],[0,"_2_itm","","Sends \"Hello, world!\" through the ITM port 0",N,N],[0,"_3_panic","","Changing the panic handler",N,N],[0,"_4_crash","","Debugging a crash (exception)",N,N],[0,"_5_exception","","Overriding an exception handler",N,N],[0,"_6_allocator","","How to use the heap and a dynamic memory allocator",N,N],[0,"_7_device","","Using a device crate",N,N]],"paths":[]};
searchIndex["cortex_m_rt"]={"doc":"Minimal startup / runtime for Cortex-M microcontrollers","items":[[3,"ExceptionFrame","cortex_m_rt","Registers stacked (pushed into the stack) during an exception",N,N],[12,"r0","","(General purpose) Register 0",0,N],[12,"r1","","(General purpose) Register 1",0,N],[12,"r2","","(General purpose) Register 2",0,N],[12,"r3","","(General purpose) Register 3",0,N],[12,"r12","","(General purpose) Register 12",0,N],[12,"lr","","Linker Register",0,N],[12,"pc","","Program Counter",0,N],[12,"xpsr","","Program Status Register",0,N],[5,"heap_start","","Returns a pointer to the start of the heap",N,N],[11,"clone","","",0,[[["self"]],["exceptionframe"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[14,"entry","","Macro to define the entry point of the program",N,N],[14,"exception","","Macro to set or override a processor core exception handler",N,N],[14,"pre_init","","Macro to set the function to be called at the beginning of the reset handler.",N,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]]],"paths":[[3,"ExceptionFrame"]]};
searchIndex["cortex_m_semihosting"]={"doc":"Semihosting for ARM Cortex-M processors","items":[[5,"syscall","cortex_m_semihosting","Performs a semihosting operation, takes a pointer to an argument block",N,[[["usize"],["t"]],["usize"]]],[5,"syscall1","","Performs a semihosting operation, takes one integer as an argument",N,[[["usize"],["usize"]],["usize"]]],[0,"debug","","Interacting with debugging agent",N,N],[4,"Exception","cortex_m_semihosting::debug","This values are taken from section 5.5.2 of ADS Debug Target Guide (DUI0058).",N,N],[13,"BranchThroughZero","","",0,N],[13,"UndefinedInstr","","",0,N],[13,"SoftwareInterrupt","","",0,N],[13,"PrefetchAbort","","",0,N],[13,"DataAbort","","",0,N],[13,"AddressException","","",0,N],[13,"IRQ","","",0,N],[13,"FIQ","","",0,N],[13,"BreakPoint","","",0,N],[13,"WatchPoint","","",0,N],[13,"StepComplete","","",0,N],[13,"RunTimeErrorUnknown","","",0,N],[13,"InternalError","","",0,N],[13,"UserInterruption","","",0,N],[13,"ApplicationExit","","",0,N],[13,"StackOverflow","","",0,N],[13,"DivisionByZero","","",0,N],[13,"OSSpecific","","",0,N],[5,"exit","","Reports to the debugger that the execution has completed.",N,[[["exitstatus"]]]],[5,"report_exception","","Report an exception to the debugger directly.",N,[[["exception"]]]],[6,"ExitStatus","","Status enum for `exit` syscall.",N,N],[17,"EXIT_SUCCESS","","Successful execution of a program.",N,N],[17,"EXIT_FAILURE","","Unsuccessful execution of a program.",N,N],[0,"hio","cortex_m_semihosting","Host I/O",N,N],[3,"HStderr","cortex_m_semihosting::hio","Host's standard error",N,N],[3,"HStdout","","Host's standard output",N,N],[5,"hstderr","","Construct a new handle to the host's standard error.",N,[[],["result",["hstderr"]]]],[5,"hstdout","","Construct a new handle to the host's standard output.",N,[[],["result",["hstdout"]]]],[11,"write_all","","Attempts to write an entire `buffer` into this sink",1,N],[11,"write_str","","",1,[[["self"],["str"]],["result"]]],[11,"write_all","","Attempts to write an entire `buffer` into this sink",2,N],[11,"write_str","","",2,[[["self"],["str"]],["result"]]],[0,"nr","cortex_m_semihosting","Semihosting operations",N,N],[0,"open","cortex_m_semihosting::nr","Values for the mode parameter of the OPEN syscall.",N,N],[17,"R","cortex_m_semihosting::nr::open","Mode corresponding to fopen \"r\" mode.",N,N],[17,"R_BINARY","","Mode corresponding to fopen \"rb\" mode.",N,N],[17,"RW","","Mode corresponding to fopen \"r+\" mode.",N,N],[17,"RW_BINARY","","Mode corresponding to fopen \"r+b\" mode.",N,N],[17,"W_TRUNC","","Mode corresponding to fopen \"w\" mode.",N,N],[17,"W_TRUNC_BINARY","","Mode corresponding to fopen \"wb\" mode.",N,N],[17,"RW_TRUNC","","Mode corresponding to fopen \"w+\" mode.",N,N],[17,"RW_TRUNC_BINARY","","Mode corresponding to fopen \"w+b\" mode.",N,N],[17,"W_APPEND","","Mode corresponding to fopen \"a\" mode.",N,N],[17,"W_APPEND_BINARY","","Mode corresponding to fopen \"ab\" mode.",N,N],[17,"RW_APPEND","","Mode corresponding to fopen \"a+\" mode.",N,N],[17,"RW_APPEND_BINARY","","Mode corresponding to fopen \"a+b\" mode.",N,N],[17,"CLOCK","cortex_m_semihosting::nr","",N,N],[17,"CLOSE","","",N,N],[17,"ELAPSED","","",N,N],[17,"ERRNO","","",N,N],[17,"FLEN","","",N,N],[17,"GET_CMDLINE","","",N,N],[17,"HEAPINFO","","",N,N],[17,"ISERROR","","",N,N],[17,"ISTTY","","",N,N],[17,"OPEN","","",N,N],[17,"READ","","",N,N],[17,"READC","","",N,N],[17,"REMOVE","","",N,N],[17,"RENAME","","",N,N],[17,"SEEK","","",N,N],[17,"SYSTEM","","",N,N],[17,"TICKFREQ","","",N,N],[17,"TIME","","",N,N],[17,"TMPNAM","","",N,N],[17,"WRITE0","","",N,N],[17,"WRITE","","",N,N],[17,"WRITEC","","",N,N],[17,"ENTER_SVC","","",N,N],[17,"REPORT_EXCEPTION","","",N,N],[14,"syscall","cortex_m_semihosting","Variable argument version of `syscall`",N,N],[14,"syscall1","","Macro version of `syscall1`",N,N],[11,"try_from","cortex_m_semihosting::debug","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_from","cortex_m_semihosting::hio","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]]],"paths":[[4,"Exception"],[3,"HStderr"],[3,"HStdout"]]};
searchIndex["panic_semihosting"]={"doc":"Report panic messages to the host stderr using semihosting","items":[],"paths":[]};
searchIndex["r0"]={"doc":"Initialization code (\"crt0\") written in Rust","items":[[5,"init_data","r0","Initializes the `.data` section",N,N],[5,"run_init_array","","",N,N],[5,"zero_bss","","Zeroes the `.bss` section",N,N],[14,"pre_init_array","","",N,N],[14,"init_array","","",N,N]],"paths":[]};
searchIndex["vcell"]={"doc":"Just like [`Cell`] but with [volatile] read / write operations","items":[[3,"VolatileCell","vcell","Just like [`Cell`] but with [volatile] read / write operations",N,N],[11,"new","","Creates a new `VolatileCell` containing the given value",0,[[["t"]],["self"]]],[11,"get","","Returns a copy of the contained value",0,[[["self"]],["t"]]],[11,"set","","Sets the contained value",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]]],"paths":[[3,"VolatileCell"]]};
searchIndex["volatile_register"]={"doc":"Volatile access to memory mapped hardware registers","items":[[3,"RO","volatile_register","Read-Only register",N,N],[3,"RW","","Read-Write register",N,N],[3,"WO","","Write-Only register",N,N],[11,"read","","Reads the value of the register",0,[[["self"]],["t"]]],[11,"modify","","Performs a read-modify-write operation",1,[[["self"],["f"]]]],[11,"read","","Reads the value of the register",1,[[["self"]],["t"]]],[11,"write","","Writes a `value` into the register",1,[[["self"],["t"]]]],[11,"write","","Writes `value` into the register",2,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]]],"paths":[[3,"RO"],[3,"RW"],[3,"WO"]]};
initSearch(searchIndex);
